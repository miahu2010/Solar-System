<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æ‰‹åŠ¿æ§åˆ¶ â€” ç²’å­å¤ªé˜³ç³»ï¼ˆæ”¹è¿›ç‰ˆï¼‰</title>

<!-- three.js ä¸ MediaPipe -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<style>
  html,body { height:100%; margin:0; background:#000; font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #canvas-container { width:100%; height:100%; overflow:hidden; touch-action:none; }
  canvas { display:block; }

  /* UI */
  #ui-container {
    position: absolute; left:16px; top:16px; width:300px;
    background: rgba(18,18,20,0.65); backdrop-filter: blur(8px); color:#eee;
    padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.05); z-index:20;
  }
  h2 { margin:0 0 10px 0; font-weight:300; font-size:1.05rem; color:#fff; }
  .control-group { margin-bottom:12px; }
  label { display:block; color:#bdbdbd; font-size:0.85rem; margin-bottom:6px; }
  .planet-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .planet-btn { background: rgba(255,255,255,0.04); border:none; color:#fff; padding:8px 6px; border-radius:8px; cursor:pointer; font-size:0.86rem; }
  .planet-btn.active, .planet-btn:hover { background: rgba(10,130,250,0.22); box-shadow: 0 4px 15px rgba(10,130,250,0.06); }

  input[type="color"] { width:100%; height:36px; border:none; padding:0; border-radius:6px; cursor:pointer; }

  #status { position:absolute; bottom:16px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.45); color:#cfcfcf; padding:8px 14px; border-radius:20px; z-index:20; font-size:0.9rem; }

  #input_video { position:absolute; right:12px; bottom:12px; width:150px; height:110px; transform:scaleX(-1); border-radius:8px; opacity:0.5; z-index:18; display:none; } /* è°ƒè¯•æ—¶å¯æ˜¾ç¤º */

  #fullscreen-btn, #toggle-ui-btn {
    position:absolute; top:16px; right:16px; width:44px; height:44px; border-radius:50%;
    background:rgba(255,255,255,0.02); color:#fff; border:1px solid rgba(255,255,255,0.04); cursor:pointer; z-index:20;
    display:flex; align-items:center; justify-content:center; font-size:16px;
  }
  #toggle-ui-btn { right:72px; }

  #info-panel {
    position:absolute; right:16px; top:16px; width:300px; background: rgba(22,22,28,0.65); padding:12px; border-radius:12px; color:#eee; z-index:20;
  }
  #info-panel h3 { margin:0 0 6px 0; color:#f6d365; font-weight:500; font-size:1rem; }
  #info-panel p { margin:6px 0; color:#cfcfcf; font-size:0.86rem; }

  @media (max-width:600px) {
    #ui-container { width: calc(100% - 32px); left:16px; top:auto; bottom:84px; }
    #info-panel { width: calc(100% - 32px); right:16px; top:12px; }
    #input_video { display:none; }
    #fullscreen-btn { top:12px; right:12px; }
    #toggle-ui-btn { top:12px; right:64px; }
  }
</style>
</head>
<body>
  <video id="input_video" autoplay muted playsinline></video>
  <div id="canvas-container"></div>

  <div id="ui-container">
    <h2>æ‰‹åŠ¿æ§åˆ¶ç²’å­å¤ªé˜³ç³»</h2>

    <div class="control-group">
      <label>é€‰æ‹©å¤©ä½“ / èšç„¦</label>
      <div class="planet-grid" id="planet-selector"></div>
    </div>

    <div class="control-group" id="color-control-group">
      <label>æ˜Ÿäº‘é¢œè‰²ï¼ˆèšç„¦æ—¶ï¼‰</label>
      <input type="color" id="color-picker" value="#aaaaaa">
    </div>

    <div style="font-size:0.82rem;color:#bdbdbd">
      äº¤äº’ï¼š<br>
      ğŸ‘‹ <b>å·¦å³åˆ’åŠ¨åŒæ‰‹ï¼š</b> ç³»ç»Ÿæ•´ä½“å·¦å³ç§»åŠ¨ï¼ˆå¹³æ»‘ï¼‰<br>
      âœŠ/ğŸ– <b>æ¡æ‹³/å¼ å¼€ï¼š</b> æ”¾å¤§/ç¼©å°ï¼ˆé•œå¤´ä¸ç²’å­å¾®è°ƒï¼‰<br>
      ğŸ‘ <b>åŒæ‰‹å¼ åˆï¼š</b> æ§åˆ¶æ˜Ÿäº‘æ‰©æ•£ä¸èšåˆ
    </div>
  </div>

  <div id="info-panel">
    <h3>å½“å‰ï¼š <span id="planet-name"></span></h3>
    <p>ğŸ”­ æ˜Ÿç­‰: <span id="planet-magnitude"></span></p>
    <p>ğŸ‘ï¸ è§‚æµ‹æç¤º: <span id="planet-obs"></span></p>
  </div>

  <div id="status">åˆå§‹åŒ–ä¸­â€¦</div>
  <button id="fullscreen-btn" onclick="toggleFullScreen()">â›¶</button>
  <button id="toggle-ui-btn" onclick="toggleUI()">âœ–</button>

<script>
/* ================= é…ç½®è¡Œæ˜Ÿæ•°æ®ï¼ˆå«æ˜Ÿç­‰ï¼‰ ================= */
const planets = [
  { name: 'Sun', color: '#FDB813', size:1.7, distance:0, speed:0, magnitude:-26.74, obs:'ç™½å¤©å¯è§ï¼ˆåˆ‡å‹¿ç›´è§†ï¼‰', focusDistance:5 },
  { name:'Mercury', color:'#A57C5B', size:0.12, distance:3.0, speed:0.018, magnitude:-1.9, obs:'é»æ˜æˆ–é»„æ˜ä½ç©ºå¯è§', focusDistance:1.4 },
  { name:'Venus', color:'#E3BB76', size:0.2, distance:4.4, speed:0.012, magnitude:-4.9, obs:'æäº®ï¼šæ™¨æ˜Ÿ/æ˜æ˜Ÿ', focusDistance:1.6 },
  { name:'Earth', color:'#2A9DF4', size:0.22, distance:6.0, speed:0.010, magnitude:-3.99, obs:'æˆ‘ä»¬çš„å®¶å›­', focusDistance:1.8 },
  { name:'Mars', color:'#D84A3B', size:0.16, distance:8.5, speed:0.008, magnitude:-2.91, obs:'çº¢è‰²æ˜¾çœ¼', focusDistance:1.5 },
  { name:'Jupiter', color:'#C88B3A', size:0.6, distance:15.0, speed:0.005, magnitude:-2.94, obs:'éå¸¸æ˜äº®', focusDistance:3.0 },
  { name:'Saturn', color:'#C5AB6E', size:0.5, distance:20.0, speed:0.004, magnitude:0.47, obs:'éœ€è¦æœ›è¿œé•œè§‚å…‰ç¯', focusDistance:2.6 },
  { name:'Uranus', color:'#4FD0E7', size:0.4, distance:25.0, speed:0.003, magnitude:5.9, obs:'è¿‘è‚‰çœ¼æé™', focusDistance:2.2 },
  { name:'Neptune', color:'#3E54E8', size:0.4, distance:30.0, speed:0.002, magnitude:7.8, obs:'éœ€æœ›è¿œé•œ', focusDistance:2.2 }
];

/* ================= Three.js åˆå§‹åŒ– ================= */
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.004);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 28);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

/* èƒŒæ™¯æ˜Ÿæ˜Ÿ */
function addStars() {
  const g = new THREE.BufferGeometry();
  const cnt = 2200;
  const arr = new Float32Array(cnt*3);
  for (let i=0;i<cnt;i++){
    arr[i*3+0] = (Math.random()-0.5)*600;
    arr[i*3+1] = (Math.random()-0.5)*600;
    arr[i*3+2] = (Math.random()-0.5)*600;
  }
  g.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const m = new THREE.PointsMaterial({ color:0xffffff, size:0.08, transparent:true, opacity:0.6 });
  const pts = new THREE.Points(g,m);
  scene.add(pts);
}
addStars();

/* ===== å‚æ•°ä¸çŠ¶æ€ ===== */
let currentMode = 'overview';
let currentFocusPlanet = planets[0];
let particleSystem = null;
let particleData = []; // å­˜å‚¨æ¯ä¸ªç²’å­çš„æœ¬åœ°ä¿¡æ¯ï¼ˆç›¸å¯¹äºæ‰€å±è¡Œæ˜Ÿä¸­å¿ƒï¼‰
const MAIN_PARTICLE_COUNT = 40000; // å¹³è¡¡å€¼ï¼šå¼ºæœºå™¨å¯æé«˜ï¼Œå¼±æœºå™¨å¯é™ä½åˆ° 20000

// æ‰‹åŠ¿ç›¸å…³çŠ¶æ€
let prevHandCenters = []; // ä¿å­˜ä¸Šä¸€æ¬¡ä¸¤æ‰‹çš„ä¸­å¿ƒç‚¹ï¼ˆç”¨äºå·¦å³æ»‘åŠ¨åˆ¤æ–­ï¼‰
let prevHandsPresent = false;
let panOffsetX = 0; // ç³»ç»Ÿæ•´ä½“å¹³ç§»
let targetPanX = 0;
let targetZoom = 1.0; // æ”¾å¤§ç¼©å°ï¼ˆæ¡æ‹³æ§åˆ¶ï¼‰
let currentZoom = 1.0;
let targetSpread = 1.0; // æ˜Ÿäº‘æ‰©æ•£ç³»æ•°ï¼ˆåŒæ‰‹å¼ åˆï¼‰
let currentSpread = 1.0;

/* ===== çº¹ç†ï¼šè½¯åœ†ç‚¹ï¼ˆcanvasï¼‰ ===== */
function makeParticleTexture(size=128){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0.0, 'rgba(255,255,255,1.0)');
  g.addColorStop(0.3, 'rgba(255,255,255,0.85)');
  g.addColorStop(0.6, 'rgba(180,180,180,0.25)');
  g.addColorStop(1.0, 'rgba(0,0,0,0.0)');
  ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
  return tex;
}
const particleSprite = makeParticleTexture(128);

/* ===== é¡¶ç‚¹/ç‰‡å…ƒç€è‰²å™¨ï¼ˆæ”¯æŒæ¯ç²’å­ size å’Œé¢œè‰² & depth attenuationï¼‰ ===== */
const vertexShader = `
  attribute float size;
  attribute vec3 customColor;
  varying vec3 vColor;
  void main(){
    vColor = customColor;
    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
    // gl_PointSize æ ¹æ®æ·±åº¦è¿›è¡Œè¡°å‡ï¼Œ200 ä¸ºç»éªŒå€¼ï¼ˆå¯è°ƒï¼‰
    gl_PointSize = size * (200.0 / -mvPos.z);
    gl_Position = projectionMatrix * mvPos;
  }
`;
const fragmentShader = `
  uniform sampler2D pointTexture;
  varying vec3 vColor;
  void main(){
    vec4 tex = texture2D(pointTexture, gl_PointCoord);
    vec3 col = vColor * (0.9 + 0.1*tex.r); // ç»™ä¸»ä½“é¢œè‰²ä¸€äº›çº¹ç†å·®å¼‚
    gl_FragColor = vec4(col, tex.a);
    if (gl_FragColor.a < 0.02) discard;
  }
`;

/* ====== å·¥å…·ï¼šçƒä½“å†…å‡åŒ€é‡‡æ · ====== */
function randomPointInSphere(radius){
  const u = Math.random();
  const cost = Math.random()*2 - 1;
  const phi = Math.random()*Math.PI*2;
  const r = Math.cbrt(u) * radius;
  const sint = Math.sqrt(1 - cost*cost);
  const x = r * sint * Math.cos(phi);
  const y = r * sint * Math.sin(phi);
  const z = r * cost;
  return new THREE.Vector3(x,y,z);
}

/* ====== æ ¹æ®æ˜Ÿç­‰æ˜ å°„åˆå§‹é¢œè‰²ï¼ˆæš—è‰²è°ƒï¼‰ =====
   ç›®çš„ï¼šè´Ÿå€¼æ˜Ÿç­‰æ›´äº®ï¼ˆä½†æˆ‘ä»¬æ•´ä½“å‹æš—ä»¥å…åˆºçœ¼ï¼‰ï¼Œæ­£å€¼æ›´æš—ã€‚
*/
function colorFromMagnitude(hexColor, magnitude){
  const base = new THREE.Color(hexColor);
  // map magnitude from [-27, +8] -> [1, 0]
  const t = (magnitude - 8) / (-27 - 8); // 1 for very negative (bright), 0 for big positive
  const clampT = Math.max(0, Math.min(1, t));
  // scale brightness between 0.28 and 0.7 (åˆ»æ„åæš—)
  const bright = 0.28 + clampT * 0.42;
  return base.clone().multiplyScalar(bright);
}

/* ====== åˆ›å»ºç²’å­ç³»ç»Ÿï¼šæ¯ä¸ªè¡Œæ˜Ÿæœ‰ body ä¸ cloudï¼Œä½ç½®ç›¸å¯¹äºè¡Œæ˜Ÿä¸­å¿ƒï¼ˆä¸å†â€œå åŠ è½¨é“â€ï¼‰ ====== */
function createParticleSystem(){
  // æ¸…ç†æ—§ç³»ç»Ÿ
  if (particleSystem){ scene.remove(particleSystem); particleSystem.geometry.dispose(); particleSystem.material.dispose(); particleData = []; }

  // ä¸´æ—¶æ•°ç»„ç”Ÿæˆå¤§é‡ç²’å­ï¼Œå†è£å‰ªåˆ° MAIN_PARTICLE_COUNT
  const temp = [];
  planets.forEach((p, idx) => {
    // åŸºäºè¡Œæ˜Ÿå°ºå¯¸åˆ†é…ä¸»ä½“ä¸äº‘å±‚æ•°é‡ï¼ˆæŒ‰æ¯”ä¾‹ï¼‰
    const bodyCount = (p.name === 'Sun') ? 4200 : Math.max(800, Math.round(1200 * p.size));
    const cloudCount = (p.name === 'Sun') ? 6000 : Math.max(1200, Math.round(2600 * p.size));

    const baseCore = colorFromMagnitude(p.color, p.magnitude);
    const cloudBase = baseCore.clone().multiplyScalar(0.85);

    for (let i=0;i<bodyCount;i++){
      const local = randomPointInSphere(p.size * 0.6); // ä¸»ä½“æ›´è‡´å¯†
      const jitter = (Math.random()*0.06) - 0.03;
      const color = baseCore.clone().multiplyScalar(0.9 + Math.random()*0.2 + jitter);
      temp.push({
        planetIdx: idx,
        type:'body',
        localPos: local,
        color: color,
        size: (p.name==='Sun')?6.0:2.3,
        orbitAngle: Math.random()*Math.PI*2,
        orbitSpeed: p.speed * (0.8 + Math.random()*0.6)
      });
    }
    for (let i=0;i<cloudCount;i++){
      const radius = p.size * (1.0 + Math.random()*2.0);
      const local = randomPointInSphere(radius);
      const color = cloudBase.clone().multiplyScalar(0.7 + Math.random()*0.5);
      temp.push({
        planetIdx: idx,
        type:'cloud',
        localPos: local,
        color: color,
        size: 0.7 + Math.random()*1.2,
        orbitAngle: Math.random()*Math.PI*2,
        orbitSpeed: p.speed * (0.6 + Math.random()*0.8)
      });
    }
  });

  // è£å‰ªä¸º MAIN_PARTICLE_COUNT
  const total = Math.min(temp.length, MAIN_PARTICLE_COUNT);
  particleData = temp.slice(0, total);

  // åˆ†é… Buffer
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(MAIN_PARTICLE_COUNT * 3);
  const colors = new Float32Array(MAIN_PARTICLE_COUNT * 3);
  const sizes = new Float32Array(MAIN_PARTICLE_COUNT);

  // åˆå§‹å†™å…¥ï¼ˆæ”¾åœ¨è¡Œæ˜Ÿä¸­å¿ƒ + localï¼‰
  for (let i=0;i<total;i++){
    const p = particleData[i];
    const planet = planets[p.planetIdx];
    // æŒ‰è¡Œæ˜Ÿè·ç¦»æ²¿ X æ”¾ç½®è¡Œæ˜Ÿä¸­å¿ƒï¼ˆåˆå§‹è§’åº¦ç”± orbitAngle å†³å®šï¼‰
    const cx = planet.distance * Math.cos(p.orbitAngle);
    const cz = planet.distance * Math.sin(p.orbitAngle);
    const x = cx + p.localPos.x;
    const y = p.localPos.y;
    const z = cz + p.localPos.z;

    positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
    colors[i*3] = p.color.r; colors[i*3+1] = p.color.g; colors[i*3+2] = p.color.b;
    sizes[i] = p.size;
  }
  for (let i=total;i<MAIN_PARTICLE_COUNT;i++){
    positions[i*3]=positions[i*3+1]=positions[i*3+2]=0;
    colors[i*3]=colors[i*3+1]=colors[i*3+2]=0;
    sizes[i]=0;
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geometry.setAttribute('customColor', new THREE.BufferAttribute(colors,3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes,1));

  const material = new THREE.ShaderMaterial({
    uniforms: { pointTexture: { value: particleSprite } },
    vertexShader, fragmentShader,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    vertexColors: true
  });

  particleSystem = new THREE.Points(geometry, material);
  scene.add(particleSystem);
}

/* ç”Ÿæˆä¸€æ¬¡ */
createParticleSystem();

/* ====== UI æ„å»ºä¸é¢œè‰²é€‰æ‹©é€»è¾‘ ====== */
const planetSelector = document.getElementById('planet-selector');
const overviewBtn = document.createElement('button');
overviewBtn.className = 'planet-btn active'; overviewBtn.innerText = 'æ€»è§ˆå¤ªé˜³ç³»';
overviewBtn.onclick = () => { document.querySelectorAll('.planet-btn').forEach(b=>b.classList.remove('active')); overviewBtn.classList.add('active'); currentMode='overview'; currentFocusPlanet = planets[0]; document.getElementById('color-control-group').style.visibility='hidden'; updateInfo(); };
planetSelector.appendChild(overviewBtn);
planets.filter(p=>p.name!=='Sun').forEach(p=>{
  const btn = document.createElement('button'); btn.className='planet-btn'; btn.innerText = p.name;
  btn.onclick = ()=>{
    document.querySelectorAll('.planet-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
    currentMode = 'focus'; currentFocusPlanet = p; document.getElementById('color-control-group').style.visibility='visible';
    document.getElementById('color-picker').value = p.color; updateInfo();
  };
  planetSelector.appendChild(btn);
});
document.getElementById('color-control-group').style.visibility='hidden';
document.getElementById('color-picker').addEventListener('input', e=>{
  // æ”¹å˜èšç„¦è¡Œæ˜Ÿçš„äº‘å±‚é¢œè‰²ï¼ˆå®æ—¶æ··åˆï¼‰
  const hex = e.target.value;
  // å°†ç›®æ ‡é¢œè‰²æ··å…¥è¯¥è¡Œæ˜Ÿ cloud é¡¶ç‚¹é¢œè‰²ï¼ˆåœ¨ animate å¾ªç¯ä¸­å¹³æ»‘è¿‡æ¸¡ï¼‰
  currentFocusPlanet._targetCloudColor = new THREE.Color(hex);
});

function updateInfo(){
  document.getElementById('planet-name').textContent = currentFocusPlanet.name;
  document.getElementById('planet-magnitude').textContent = currentFocusPlanet.magnitude + ' M';
  document.getElementById('planet-obs').textContent = currentFocusPlanet.obs || '';
}
updateInfo();

/* ====== MediaPipe Hands åˆå§‹åŒ– & æ‰‹åŠ¿åˆ¤å®š ====== */
const videoElement = document.getElementById('input_video');
const statusEl = document.getElementById('status');

// å¯åŠ¨æ‘„åƒå¤´ï¼ˆCamera helperï¼‰
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.55, minTrackingConfidence: 0.5 });
hands.onResults(onHandsResults);

const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width:640, height:480 });
cameraUtils.start().then(()=>{ /* å¯é€‰æ˜¾ç¤ºè§†é¢‘ç”¨äºè°ƒè¯• */ /* videoElement.style.display='block'; */ }).catch(err=>{ statusEl.innerText='æ‘„åƒå¤´ä¸å¯ç”¨'; console.error(err); });

// ä¿å­˜ä¸Šå¸§æ‰‹éƒ¨ä¸­å¿ƒä¸å¼€åˆåº¦ï¼Œç”¨äºåˆ¤æ–­å·¦å³æ»‘åŠ¨ä¸æ¡æ‹³
let lastFrameHandCenters = []; // [{x,y},...]
let lastFrameTime = performance.now();

function landmarkToPoint(landmark){
  // landmark.x/y in [0,1] relative to image, flip X as we mirror the video
  return { x: landmark.x, y: landmark.y };
}

// è®¡ç®—â€œå¼ å¼€åº¦â€æŒ‡æ ‡ï¼šå–äº”ä¸ªæŒ‡å°–ï¼ˆ4,8,12,16,20ï¼‰åˆ°è…•éƒ¨(0)è·ç¦»çš„å¹³å‡
function computeOpenScore(landmarks){
  const wrist = landmarks[0];
  const tips = [4,8,12,16,20];
  let sum=0;
  tips.forEach(i=> {
    const dx = landmarks[i].x - wrist.x;
    const dy = landmarks[i].y - wrist.y;
    sum += Math.sqrt(dx*dx + dy*dy);
  });
  return sum / tips.length; // æ›´å¤§è¡¨ç¤ºè¶Šå¼ å¼€
}

// ä¸»å›è°ƒï¼šå¾—åˆ°æ¯å¸§æ‰‹éƒ¨ä¿¡æ¯
function onHandsResults(results){
  if (!results.multiHandLandmarks || results.multiHandLandmarks.length===0){
    // æ— æ‰‹ï¼šå¹³æ»‘å¤ä½
    statusEl.innerText = 'æœªæ£€æµ‹åˆ°æ‰‹éƒ¨';
    statusEl.style.color = '#c7c7c7';
    prevHandsPresent = false;
    // ç›®æ ‡å€¼å›å½’
    targetPanX += (0 - targetPanX) * 0.05;
    targetSpread += (1.0 - targetSpread) * 0.06;
    targetZoom += (1.0 - targetZoom) * 0.06;
    return;
  }
  statusEl.innerText = 'æ£€æµ‹åˆ°æ‰‹éƒ¨ â€” è¯·äº¤äº’';
  statusEl.style.color = '#7ee3ff';

  // è®¡ç®—æ¯åªæ‰‹çš„ä¸­å¿ƒï¼ˆä½¿ç”¨ä¸­æŒ‡ MCP / æˆ–æ‰‹æŒä¸­å¿ƒï¼‰
  const centers = results.multiHandLandmarks.map(landmarks => {
    // è®¡ç®— palm center: average of wrist(0), index_mcp(5), pinky_mcp(17)
    const cx = (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3;
    const cy = (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3;
    return { x: cx, y: cy, landmarks: landmarks };
  });

  // å¤„ç†å·¦å³æ»‘åŠ¨ï¼šæ¯”è¾ƒ centers ä¸ lastFrameHandCenters çš„å¹³å‡ dx
  if (lastFrameHandCenters.length === centers.length){
    // compute avg dx
    let avgDx = 0;
    for (let i=0;i<centers.length;i++){
      avgDx += (centers[i].x - lastFrameHandCenters[i].x);
    }
    avgDx /= centers.length;
    // æŠŠ screen-space dx è½¬æ¢ä¸º pan ç›®æ ‡ï¼ˆæ”¾å¤§ç³»æ•°ä»¥æ„Ÿè§‰æ›´çµæ•ï¼‰
    targetPanX += -avgDx * 5.0; // è´Ÿå·å› ä¸ºåæ ‡ç³»
    // é™å¹…
    targetPanX = Math.max(Math.min(targetPanX, 12), -12);
  } else {
    // å¦‚æœæ‰‹æ•°å˜åŒ–ï¼Œè½»å¾®è¡°å‡pan
    targetPanX += (0 - targetPanX) * 0.02;
  }

  // åŒæ‰‹å¼ åˆï¼ˆå¦‚æœæ£€æµ‹åˆ°ä¸¤åªæ‰‹ï¼‰ï¼šæ§åˆ¶ spread
  if (centers.length === 2){
    const dx = centers[0].x - centers[1].x;
    const dy = centers[0].y - centers[1].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    // dist åœ¨ [0..~0.8] èŒƒå›´ï¼›æ˜ å°„åˆ° [0.6 .. 2.2] ä¹‹é—´
    const newSpread = 0.6 + Math.min(Math.max(dist*2.6,0),1.6);
    targetSpread += (newSpread - targetSpread) * 0.45; // æ›´å¿«å“åº”
  } else {
    // å•æ‰‹æ—¶é€æ­¥å›å½’
    targetSpread += (1.0 - targetSpread) * 0.06;
  }

  // æ¡æ‹³/å¼ å¼€æ£€æµ‹ï¼šå¯¹æ¯åªæ‰‹è®¡ç®— open scoreï¼ˆä¸ç»éªŒé˜ˆå€¼æ¯”è¾ƒï¼‰
  let anyFist = false, anyOpen = false;
  centers.forEach(c => {
    const score = computeOpenScore(c.landmarks);
    // é˜ˆå€¼ç»éªŒå€¼ï¼šå¦‚æœ score < 0.06 -> å‡ ä¹æ¡æ‹³ï¼›>0.11 -> æ˜æ˜¾å¼ å¼€ï¼ˆè§†é¢‘/åˆ†è¾¨ç‡å·®å¼‚ä¼šå½±å“ï¼‰
    if (score < 0.065) anyFist = true;
    if (score > 0.11) anyOpen = true;
  });
  // ä¼˜å…ˆæ¡æ‹³è§¦å‘æ”¾å¤§
  if (anyFist && !anyOpen) {
    // æ¡æ‹³ï¼šæ”¾å¤§ï¼ˆé•œå¤´é è¿‘ï¼‰
    targetZoom = 0.65; // <1 è¡¨ç¤ºè¾ƒè¿‘
  } else if (anyOpen && !anyFist) {
    targetZoom = 1.3; // å¼ å¼€ï¼šç¨å¾®æ‹‰è¿œ
  } else {
    // ä¸­é—´çŠ¶æ€å¹³æ»‘å½’ä¸€
    targetZoom += (1.0 - targetZoom) * 0.08;
  }

  // ä¿å­˜å½“å‰ centers ä¾›ä¸‹ä¸€å¸§æ¯”è¾ƒ
  lastFrameHandCenters = centers.map(c => ({ x:c.x, y:c.y }));
  prevHandsPresent = true;
}

/* ====== æ¸²æŸ“ä¸åŠ¨ç”»å¾ªç¯ ====== */
let lastTime = performance.now();

function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // å¹³æ»‘ç›®æ ‡å€¼
  panOffsetX += (targetPanX - panOffsetX) * 0.08;
  currentSpread += (targetSpread - currentSpread) * 0.14;
  currentZoom += (targetZoom - currentZoom) * 0.06;

  // æ›´æ–°æ‰€æœ‰ç²’å­çš„ä½ç½®ï¼ˆæ ¹æ®å®ƒä»¬çš„è¡Œæ˜Ÿä¸­å¿ƒã€å…¬è½¬è§’åº¦ä¸æœ¬åœ°åæ ‡ï¼‰
  if (!particleSystem) return;
  const posArr = particleSystem.geometry.attributes.position.array;
  const colorArr = particleSystem.geometry.attributes.customColor.array;
  const sizeArr = particleSystem.geometry.attributes.size.array;

  // å…ˆè®¡ç®—æ¯ä¸ªè¡Œæ˜Ÿçš„å½“å‰ä¸­å¿ƒä½ç½®ï¼ˆç”± orbitAngle æ¨åŠ¨ï¼‰
  const planetCenters = planets.map((p, idx) => {
    // è¡Œæ˜Ÿæœ‰ä¸€ä¸ªåŸºäºæ—¶é—´çš„å…¨å±€æ—‹è½¬è§’åº¦ï¼ˆè¿™é‡Œä½¿ç”¨ performance.nowï¼‰
    // æˆ‘ä»¬ä¹Ÿå¯ä»¥åŸºäºç²’å­çš„ orbitAngle ä¿å­˜å•ç‹¬è§’åº¦ï¼›è¿™é‡Œä»¥è¡Œæ˜Ÿä¸ºåŸºå‡†ï¼Œé¿å…æ¯ä¸ªç²’å­ç‹¬ç«‹æŠ–åŠ¨
    // ç”Ÿæˆä¸€ä¸ªè¡Œæ˜ŸåŸºè§’ï¼ˆå– time * p.speedï¼‰
    const baseAngle = (now * 0.0002) * p.speed * 60.0 + (idx * 0.37); // idx*0.37 è®©åˆå§‹åˆ†å¸ƒæ›´é”™è½
    const cx = (p.distance) * Math.cos(baseAngle) + panOffsetX; // panOffsetX å½±å“ X è½´æ•´ä½“å¹³ç§»
    const cz = (p.distance) * Math.sin(baseAngle);
    return new THREE.Vector3(cx, 0, cz);
  });

  // æŠŠç²’å­æ”¾ç½®åœ¨å…¶è¡Œæ˜Ÿä¸­å¿ƒåŠ ä¸Šæœ¬åœ°åæ ‡ï¼ˆå¹¶åœ¨ local åæ ‡ä¸Šåšå¾®è‡ªè½¬å’Œ spreadï¼‰
  for (let i=0;i<particleData.length;i++){
    const pd = particleData[i];
    const center = planetCenters[pd.planetIdx];
    // è‡ªè½¬è§’åº¦åšå°å¹…æ—¶é—´ä¾èµ–æ—‹è½¬ï¼Œä½¿è¡Œæ˜Ÿâ€œæ´»â€èµ·æ¥
    const rot = now * 0.00008 * ( (pd.type==='body')?0.6:1.4 );
    const cosr = Math.cos(rot + pd.orbitAngle*0.15);
    const sinr = Math.sin(rot + pd.orbitAngle*0.15);

    let localX = pd.localPos.x;
    let localY = pd.localPos.y;
    let localZ = pd.localPos.z;

    // è®©äº‘å±‚ç¨å¾®å‘å¤–æ‰©æ•£ï¼Œå— currentSpread æ§åˆ¶
    if (pd.type === 'cloud') {
      localX *= (1.0 + (currentSpread-1.0) * 0.9);
      localY *= (1.0 + (currentSpread-1.0) * 0.6);
      localZ *= (1.0 + (currentSpread-1.0) * 0.9);
    }

    // æ—‹è½¬ local åæ ‡ä»¥æ¨¡æ‹Ÿè¡Œæ˜Ÿè‡ªè½¬
    const rx = localX * cosr - localZ * sinr;
    const rz = localX * sinr + localZ * cosr;

    // ä½ç½® = è¡Œæ˜Ÿä¸­å¿ƒ + localRotated
    const x = center.x + rx;
    const y = center.y + localY;
    const z = center.z + rz;

    posArr[i*3] = x;
    posArr[i*3+1] = y;
    posArr[i*3+2] = z;

    // å¦‚æœå½“å‰ä¸ºèšç„¦æ¨¡å¼å¹¶ä¸”ç²’å­å±äºèšç„¦è¡Œæ˜Ÿçš„äº‘å±‚ï¼Œåˆ™å¹³æ»‘æ··åˆåˆ°ç”¨æˆ·é€‰çš„é¢œè‰²ï¼ˆå¦‚æœè®¾ç½®ï¼‰
    if (currentMode === 'focus' && planets[pd.planetIdx].name === currentFocusPlanet.name && pd.type === 'cloud') {
      const targetColor = (currentFocusPlanet._targetCloudColor) ? currentFocusPlanet._targetCloudColor : planets[pd.planetIdx].color;
      // targetColor å¯èƒ½ä¸º hex æˆ– Color å¯¹è±¡
      const tc = (targetColor instanceof THREE.Color) ? targetColor : new THREE.Color(targetColor);
      // ä»…åšéƒ¨åˆ†æ··å…¥ï¼Œé¿å…çªç„¶å˜è‰²
      colorArr[i*3] += (tc.r * 0.8 - colorArr[i*3]) * 0.06;
      colorArr[i*3+1] += (tc.g * 0.8 - colorArr[i*3+1]) * 0.06;
      colorArr[i*3+2] += (tc.b * 0.8 - colorArr[i*3+2]) * 0.06;
      // äº‘åœ¨èšç„¦æ—¶æ”¾å¤§ä¸€ç‚¹ï¼ˆä½†ä¸ä¼šè¿‡åº¦ï¼‰
      sizeArr[i] = pd.size * (1.0 + 0.28 * (currentZoom-1.0));
    } else {
      // æ™®é€šæ·¡å…¥æ·¡å‡ºï¼ˆç¡®ä¿é¢œè‰²æ•°å€¼ç¨³å®šï¼‰
      colorArr[i*3] += (pd.color.r - colorArr[i*3]) * 0.04;
      colorArr[i*3+1] += (pd.color.g - colorArr[i*3+1]) * 0.04;
      colorArr[i*3+2] += (pd.color.b - colorArr[i*3+2]) * 0.04;
      sizeArr[i] = pd.size * ( (pd.type==='body')?1.05:0.9 );
    }
  }

  // æ ‡è®°æ›´æ–°
  particleSystem.geometry.attributes.position.needsUpdate = true;
  particleSystem.geometry.attributes.customColor.needsUpdate = true;
  particleSystem.geometry.attributes.size.needsUpdate = true;

  // ç›¸æœºï¼šå¦‚æœèšç„¦æŸä¸ªè¡Œæ˜Ÿï¼Œåˆ™æ‘„åƒæœºé è¿‘è¯¥è¡Œæ˜Ÿä¸­å¿ƒå¹¶å— currentZoom å½±å“ï¼›å¦åˆ™åœ¨æ•´ä½“è¿œå¤„ï¼Œæ€»è§ˆå¹¶å— currentZoom å½±å“
  if (currentMode === 'focus' && currentFocusPlanet) {
    // æ‰¾åˆ°è¡Œæ˜Ÿä¸­å¿ƒï¼ˆé‡ç”¨å‰é¢è®¡ç®—ï¼‰
    const idx = planets.findIndex(pp=>pp.name === currentFocusPlanet.name);
    const center = planetCenters[idx] || new THREE.Vector3(0,0,0);
    // è®¡ç®—æœŸæœ›ç›¸æœºä½ç½®ï¼šåœ¨è¡Œæ˜Ÿå‰æ–¹ä¸€ç‚¹ï¼ˆåŸºäº focusDistanceï¼‰
    const fd = currentFocusPlanet.focusDistance || 2.0;
    const camOffset = new THREE.Vector3(fd * 0.6, fd*0.3, fd * 1.1);
    // å¾®æ—‹è½¬åŸºäº panOffsetX
    const angle = panOffsetX * 0.02;
    const sinA = Math.sin(angle), cosA = Math.cos(angle);
    const rx = camOffset.x * cosA - camOffset.z * sinA;
    const rz = camOffset.x * sinA + camOffset.z * cosA;
    const desired = new THREE.Vector3(center.x + rx, center.y + camOffset.y, center.z + rz);
    camera.position.lerp(desired, 0.09);
    // è®©ç›¸æœºé è¿‘æˆ–è¿œç¦»å— currentZoom æ§åˆ¶ï¼ˆ<1æ›´è¿‘ï¼‰
    camera.position.multiplyScalar( currentZoom );
    camera.lookAt(center);
  } else {
    // æ€»è§ˆæ¨¡å¼ï¼šå›ºå®šè¿œå¤„è§†è§’ï¼Œå¯å— panOffsetX æ—‹è½¬
    const desired = new THREE.Vector3(0, 10, 28);
    desired.x += panOffsetX * 0.6;
    camera.position.lerp(desired, 0.06);
    camera.lookAt( new THREE.Vector3(panOffsetX * 0.25, 0, 0) );
  }

  renderer.render(scene, camera);
}
animate();

/* ====== åˆå§‹åŒ–ç²’å­æ•°æ®ï¼ˆæŠŠé¢œè‰²å±æ€§è½¬ä¸º numeric arraysï¼‰ ====== */
function prepareParticleDataForLoop(){
  // æŠŠ particleData ä» createParticleSystem ä¸­çš„ä¸´æ—¶ pd å¤åˆ¶ä¸ºå¯åœ¨ loop ä½¿ç”¨çš„ç»“æ„ï¼ˆå« THREE.Colorï¼‰
  particleData.forEach(pd=>{
    if (!(pd.color instanceof THREE.Color)) pd.color = new THREE.Color(pd.color);
    if (!pd.localPos) pd.localPos = new THREE.Vector3();
  });
}
prepareParticleDataForLoop();

/* ====== è°ƒæ•´ï¼šå½“ createParticleSystem() è¢«è°ƒç”¨åéœ€è¦ prepareParticleDataForLoop() å†è¿è¡Œä¸€æ¬¡ */
/* å¦‚æœä½ æƒ³åŠ¨æ€æ›´æ”¹ MAIN_PARTICLE_COUNT æˆ–é‡æ–°ç”Ÿæˆç²’å­ï¼Œè¯·è°ƒç”¨ï¼š
     createParticleSystem();
     prepareParticleDataForLoop();
*/

/* ====== çª—å£ä¸ UI åŠŸèƒ½ ====== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

let uiHidden = false;
function toggleUI(){
  const ui = document.getElementById('ui-container'), info = document.getElementById('info-panel'), btn = document.getElementById('toggle-ui-btn');
  if (!uiHidden) { ui.style.transform = 'translateX(-360px)'; info.style.transform='translateX(360px)'; btn.innerText='â˜°'; }
  else { ui.style.transform='translateX(0)'; info.style.transform='translateX(0)'; btn.innerText='âœ–'; }
  uiHidden = !uiHidden;
}
function toggleFullScreen(){
  if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
  else document.exitFullscreen();
}

/* ====== å¸§ç‡ / æ€§èƒ½å»ºè®®ï¼ˆä¸ä¼šè‡ªåŠ¨æ”¹å˜ï¼‰ ======
 - å¦‚æœæµè§ˆå™¨å¡é¡¿ï¼šæŠŠ MAIN_PARTICLE_COUNT è°ƒå°åˆ° 25000 æˆ– 18000ã€‚
 - ä½ ä¹Ÿå¯ä»¥æŠŠ bodyCount & cloudCount é…æ¯”æ”¹ä½ï¼ˆåœ¨ createParticleSystem ä¸­ï¼‰ã€‚
*/

/* ====== è¯´æ˜ç»“æŸï¼šç°åœ¨é¡µé¢åº”è¯¥æ»¡è¶³ä»¥ä¸‹ç‚¹ï¼š
   - æ¯ä¸ªè¡Œæ˜Ÿç”±ç‹¬ç«‹ä½“ç§¯ç²’å­ç»„æˆï¼ˆä¸å†æ˜¯è½¨é“ï¼‰
   - åŒæ‰‹å·¦å³æ»‘åŠ¨æ•´ä½“å¹³ç§»ï¼ˆå¹³æ»‘ï¼‰
   - æ¡æ‹³æ”¾å¤§ / å¼ å¼€ç¼©å°ï¼ˆç›¸æœº + ç²’å­å¾®è°ƒï¼‰
   - åŒæ‰‹å¼ åˆæ§åˆ¶æ˜Ÿäº‘æ‰©æ•£
   - èšç„¦è¡Œæ˜Ÿæ—¶å¯ä»¥ç”¨é¢œè‰²é€‰æ‹©å™¨è°ƒæ•´äº‘å±‚é¢œè‰²ï¼ˆåˆå§‹é¢œè‰²æ ¹æ®æ˜Ÿç­‰é™ä½äº®åº¦ï¼‰
   - ç•Œé¢ç®€æ´ã€æ”¯æŒç§»åŠ¨ç«¯
*/
</script>
</body>
</html>
