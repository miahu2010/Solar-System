<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar Dust VI - Pure Math (No Squares)</title>
    <style>
        :root {
            --bg: #020202; /* 极深的黑灰，不是纯黑 */
            --glass: rgba(30, 30, 30, 0.4);
            --border: rgba(255, 255, 255, 0.1);
            --text: #cfcfcf;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', sans-serif;
            color: var(--text);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #input-video { display: none; }

        /* 极简 UI */
        .ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; }
        
        .panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 15px;
            position: absolute;
            transition: opacity 0.4s;
        }

        /* 左侧导航 */
        #nav-panel { top: 30px; left: 30px; width: 180px; }
        .nav-btn {
            display: block; width: 100%; text-align: left; background: none; border: none;
            color: #666; font-size: 11px; letter-spacing: 2px; padding: 8px 0;
            cursor: pointer; transition: 0.3s; text-transform: uppercase;
        }
        .nav-btn:hover { color: #fff; padding-left: 5px; }
        .nav-btn.active { color: #fff; font-weight: bold; }

        /* 右侧信息 */
        #info-panel { 
            bottom: 40px; right: 40px; width: 240px; 
            opacity: 0; transform: translateY(10px);
        }
        #info-panel.show { opacity: 1; transform: translateY(0); }
        
        h1 { margin: 0; font-size: 24px; font-weight: 200; color: #fff; letter-spacing: 3px; }
        .sub { display: block; font-size: 9px; color: #888; letter-spacing: 1px; margin-bottom: 10px; }
        p { font-size: 11px; line-height: 1.5; color: #aaa; }
        .data { display: flex; justify-content: space-between; margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; font-size: 10px; font-family: monospace; }

        /* 底部提示 */
        #hint {
            position: absolute; bottom: 30px; left: 30px; 
            font-size: 10px; color: #444; letter-spacing: 1px;
        }
        #cam-status {
            display: inline-block; width: 6px; height: 6px; background: #333; 
            border-radius: 50%; margin-right: 8px; transition: 0.3s;
        }
        #cam-status.on { background: #fff; box-shadow: 0 0 8px #fff; }

        /* 启动页 */
        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 99;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }
        .btn-enter {
            background: transparent; border: 1px solid #333; color: #fff;
            padding: 10px 40px; letter-spacing: 5px; cursor: pointer;
            transition: 0.3s; font-size: 10px; margin-top: 20px;
        }
        .btn-enter:hover { border-color: #fff; background: rgba(255,255,255,0.1); }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="start-screen">
        <div style="font-size: 30px; font-weight: 100; letter-spacing: 10px; opacity: 0.8;">SOLAR MIST</div>
        <div style="font-size: 10px; color: #444; margin-top: 10px;">GENERATIVE PARTICLE SYSTEM</div>
        <button class="btn-enter" id="btn-start">INITIALIZE</button>
    </div>

    <div class="ui-layer">
        <div id="nav-panel" class="panel">
            <div id="nav-list"></div>
        </div>

        <div id="info-panel" class="panel">
            <h1 id="p-name">EARTH</h1>
            <span class="sub" id="p-type">TERRESTRIAL PLANET</span>
            <p id="p-desc">Our home.</p>
            <div class="data">
                <span id="p-data1">DIA: 12742 KM</span>
                <span id="p-data2">TEMP: 15°C</span>
            </div>
        </div>

        <div id="hint">
            <div id="cam-status"></div>
            <span>HAND GESTURE: OPEN (MIST) / FIST (SOLID)</span>
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute float randomSeed; // 每个粒子独特的种子
        
        uniform float uTime;
        uniform float uFist; // 0.0 = 雾, 1.0 = 实心
        
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            vColor = color;
            vec3 p = position;

            // --- 动态效果 ---
            
            // 1. 雾化扩散 (Mist Expansion)
            // 当手张开(uFist=0)时，粒子根据 randomSeed 向外炸开
            vec3 mistOffset = normalize(p) * (length(p) * 2.5 * randomSeed); 
            
            // 2. 自由浮动 (Floating)
            // 使用正弦波模拟呼吸感
            float floatSpeed = 0.5;
            float floatAmp = 1.0 + (1.0 - uFist) * 2.0; // 雾化状态下浮动幅度更大
            
            p.x += sin(uTime * floatSpeed + randomSeed * 10.0) * floatAmp;
            p.y += cos(uTime * floatSpeed * 0.8 + randomSeed * 20.0) * floatAmp;
            p.z += sin(uTime * floatSpeed * 0.5 + randomSeed * 30.0) * floatAmp;

            // 3. 状态混合
            // 在 雾化位置(p + mistOffset) 和 原始球体位置(p) 之间插值
            vec3 finalPos = mix(p + mistOffset, p, uFist); // uFist控制混合

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            
            // 大小计算：近大远小
            float finalSize = size * (2.0 - uFist * 0.5); // 雾化时粒子大一点，看起来更朦胧
            gl_PointSize = finalSize * (150.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;

            // 透明度：雾化时透明，实心时不透明
            vAlpha = 0.3 + uFist * 0.7;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        varying float vAlpha;
        
        void main() {
            // --- 彻底修复白色方块 ---
            // gl_PointCoord 是粒子内部坐标 (0,0 到 1,1)
            // 我们计算到中心的距离
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);

            // 如果距离大于0.5（即在圆圈外），直接丢弃，不显示任何颜色
            // 这一步把方块切成了圆
            if (dist > 0.5) discard;

            // 制作柔和边缘 (Glow)
            // 距离中心越近越亮
            float glow = 1.0 - (dist * 2.0); // 0.0 到 1.0
            glow = pow(glow, 2.0); // 指数衰减，看起来更像光晕

            // 最终颜色
            gl_FragColor = vec4(vColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- 莫兰迪/高级灰配色 (低饱和度) ---
        const DB = [
            { name: "System", type: "Overview", color: [1,1,1], r: 0, d: 0, s: 0 },
            { name: "Sun", type: "Star", color: [1.0, 0.95, 0.9], r: 10, d: 0, s: 0, desc: "Silent Light source.", data: ["1.39M km", "5500°C"] },
            { name: "Mercury", type: "Planet", color: [0.7, 0.7, 0.72], r: 2, d: 25, s: 0.5, desc: "Grey stone world.", data: ["4879 km", "167°C"] },
            { name: "Venus", type: "Planet", color: [0.8, 0.75, 0.65], r: 3.5, d: 40, s: 0.4, desc: "Pale gold clouds.", data: ["12104 km", "464°C"] },
            { name: "Earth", type: "Planet", color: [0.4, 0.55, 0.7], r: 3.8, d: 60, s: 0.3, desc: "Blue atmosphere.", data: ["12742 km", "15°C"] },
            { name: "Mars", type: "Planet", color: [0.75, 0.45, 0.4], r: 2.5, d: 80, s: 0.25, desc: "Red dust.", data: ["6779 km", "-65°C"] },
            { name: "Jupiter", type: "Gas Giant", color: [0.7, 0.65, 0.6], r: 9, d: 110, s: 0.15, desc: "Massive storms.", data: ["139820 km", "-110°C"] },
            { name: "Saturn", type: "Gas Giant", color: [0.75, 0.7, 0.55], r: 8, d: 150, s: 0.1, ring: true, desc: "Ringed beauty.", data: ["116460 km", "-140°C"] },
            { name: "Uranus", type: "Ice Giant", color: [0.6, 0.7, 0.75], r: 6, d: 190, s: 0.08, desc: "Cyan ice.", data: ["50724 km", "-195°C"] },
            { name: "Neptune", type: "Ice Giant", color: [0.35, 0.4, 0.7], r: 6, d: 220, s: 0.06, desc: "Deep blue.", data: ["49244 km", "-200°C"] }
        ];

        let scene, camera, renderer, controls;
        let uniforms;
        let pGroups = []; // 公转组
        let pMeshes = []; // 粒子网格引用
        let activeIdx = 0; // 0 = system

        // 状态
        let state = {
            fist: 0.0, // 默认张开 (雾)
            targetFist: 0.0
        };

        // --- Init ---
        document.getElementById('btn-start').addEventListener('click', () => {
            const screen = document.getElementById('start-screen');
            screen.style.opacity = 0;
            setTimeout(() => screen.style.display = 'none', 800);
            initCam();
            init3D();
        });

        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // 极淡的雾，防止背景死黑
            scene.fog = new THREE.FogExp2(0x020202, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 100, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x020202);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Shader 参数
            uniforms = {
                uTime: { value: 0 },
                uFist: { value: 0.0 }
            };

            // 创建场景内容
            createStars();
            DB.forEach((d, i) => {
                if(i===0) return; // 跳过 System Overview
                createPlanet(d, i);
            });

            createUI();
            animate();
            window.addEventListener('resize', onResize);
        }

        // --- 创建无方块粒子 ---
        function createPlanet(data, index) {
            const pivot = new THREE.Group();
            scene.add(pivot);

            // 粒子数：不用太多，保证流畅
            const count = data.name === "Sun" ? 4000 : 1200;
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const seeds = []; // 随机种子

            const baseCol = new THREE.Color(data.color[0], data.color[1], data.color[2]);
            const hsl = {}; baseCol.getHSL(hsl);

            for(let i=0; i<count; i++) {
                // 球体分布
                const r = data.r * Math.pow(Math.random(), 0.4); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );

                // 颜色：低饱和微调
                const c = new THREE.Color().setHSL(hsl.h, hsl.s * 0.7, hsl.l + (Math.random()-0.5)*0.2);
                colors.push(c.r, c.g, c.b);

                sizes.push(Math.random() * 2.0 + 0.5);
                seeds.push(Math.random());
            }

            // 土星环
            if(data.ring) {
                for(let i=0; i<800; i++) {
                    const r = data.r * (1.5 + Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    positions.push(r*Math.cos(theta), (Math.random()-0.5)*0.2, r*Math.sin(theta));
                    colors.push(0.7, 0.7, 0.65);
                    sizes.push(0.8);
                    seeds.push(Math.random());
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('randomSeed', new THREE.Float32BufferAttribute(seeds, 1));

            // 材质使用 Shader
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending, // 加法混合 (光叠加)
                depthTest: false, // 禁用深度测试以获得半透明叠加效果
                transparent: true
            });

            const mesh = new THREE.Points(geometry, material);
            mesh.position.x = data.d; // 设置初始距离
            pivot.add(mesh);

            // 保存
            pGroups.push({ pivot, speed: data.s });
            pMeshes.push(mesh); // 注意：pMeshes[0] 对应 Mercury (索引1)

            // 轨道线 (极细)
            if(data.d > 0) {
                const orbitGeo = new THREE.RingGeometry(data.d-0.05, data.d+0.05, 128);
                orbitGeo.rotateX(-Math.PI/2);
                const orbitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.04, side:THREE.DoubleSide });
                scene.add(new THREE.Mesh(orbitGeo, orbitMat));
            }
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1500; i++) {
                const r = 400 + Math.random()*200;
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(Math.random()*2-1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0x444444, size:1.5, sizeAttenuation:false, transparent:true, opacity:0.5});
            scene.add(new THREE.Points(geo, mat));
        }

        // --- 逻辑 ---
        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now() * 0.001;
            uniforms.uTime.value = t;
            TWEEN.update();

            // 手势平滑过渡
            state.fist += (state.targetFist - state.fist) * 0.05;
            uniforms.uFist.value = state.fist;

            // 公转
            pGroups.forEach(g => {
                g.pivot.rotation.y += g.speed * 0.001;
            });

            // 锁定镜头
            if (activeIdx > 0) {
                // pMeshes 数组从0开始存的是 Mercury，所以要减去1
                const targetMesh = pMeshes[activeIdx - 1];
                const worldPos = new THREE.Vector3();
                targetMesh.getWorldPosition(worldPos);
                controls.target.lerp(worldPos, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function switchTarget(index) {
            activeIdx = index;
            document.querySelectorAll('.nav-btn').forEach((b, i) => {
                b.classList.toggle('active', i === index);
            });

            const panel = document.getElementById('info-panel');
            
            if (index === 0) {
                // System View
                panel.classList.remove('show');
                controls.autoRotate = true;
                
                new TWEEN.Tween(camera.position).to({x:0, y:100, z:200}, 1500).easing(TWEEN.Easing.Quadratic.Out).start();
                new TWEEN.Tween(controls.target).to({x:0, y:0, z:0}, 1500).start();
            } else {
                // Planet View
                controls.autoRotate = false; // 停止自旋，专心看
                const d = DB[index];
                
                document.getElementById('p-name').innerText = d.name.toUpperCase();
                document.getElementById('p-type').innerText = d.type.toUpperCase();
                document.getElementById('p-desc').innerText = d.desc;
                document.getElementById('p-data1').innerText = `DIA: ${d.data[0]}`;
                document.getElementById('p-data2').innerText = `TMP: ${d.data[1]}`;
                panel.classList.add('show');

                // 飞向星球
                // 这里只做大概的飞入，主要的居中靠 animate 中的 lerp
                const targetMesh = pMeshes[index - 1];
                // 稍微拉近一点相机的 zoom
                // 我们不改变相机位置（让用户自己转），但可以缩小距离限制
                controls.minDistance = d.r * 2.5; 
            }
        }

        function createUI() {
            const list = document.getElementById('nav-list');
            DB.forEach((d, i) => {
                const btn = document.createElement('button');
                btn.className = 'nav-btn';
                btn.innerText = d.name;
                if(i===0) btn.classList.add('active');
                btn.onclick = () => switchTarget(i);
                list.appendChild(btn);
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Hand Tracking ---
        async function initCam() {
            const video = document.getElementById('input-video');
            const status = document.getElementById('cam-status');
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5});
            
            hands.onResults(res => {
                if(res.multiHandLandmarks.length > 0) {
                    status.classList.add('on');
                    const lm = res.multiHandLandmarks[0];
                    // 握拳检测：指尖 vs 指根
                    const wrist = lm[0];
                    const tip = lm[12]; 
                    const base = lm[9];
                    
                    const dTip = Math.hypot(tip.x-wrist.x, tip.y-wrist.y);
                    const dBase = Math.hypot(base.x-wrist.x, base.y-wrist.y);
                    
                    if(dTip < dBase * 1.0) state.targetFist = 1.0; // 握拳 = 实心
                    else state.targetFist = 0.0; // 张开 = 雾
                } else {
                    status.classList.remove('on');
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240
            });
            cam.start();
        }
    </script>
</body>
</html>
