<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>柔和尘埃粒子云效果</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #000010 0%, #000 100%);
      font-family: sans-serif;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // === 参数 ===
    const MAIN_PARTICLE_COUNT = 28000;
    const PARTICLE_SIZE = 20;
    const CLOCK = new THREE.Clock();

    // === 场景基础 ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 150;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // === 粒子纹理 ===
    function makeParticleTexture() {
      const size = 128;
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      g.addColorStop(0.0, "rgba(255,255,255,1.0)");
      g.addColorStop(0.2, "rgba(255,255,255,0.6)");
      g.addColorStop(0.5, "rgba(200,200,200,0.15)");
      g.addColorStop(1.0, "rgba(0,0,0,0.0)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(canvas);
    }

    const particleSprite = makeParticleTexture();

    // === 粒子几何与属性 ===
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(MAIN_PARTICLE_COUNT * 3);
    const colors = new Float32Array(MAIN_PARTICLE_COUNT * 3);
    const sizes = new Float32Array(MAIN_PARTICLE_COUNT);

    const color = new THREE.Color();
    const particleData = [];

    for (let i = 0; i < MAIN_PARTICLE_COUNT; i++) {
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const radius = 80 + Math.random() * 40;

      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);

      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;

      const clampT = Math.random();
      const bright = 0.22 + clampT * 0.38;
      color.setHSL(0.58 + Math.random() * 0.1, 0.55, bright);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;

      sizes[i] = PARTICLE_SIZE * (0.8 + Math.random() * 1.2);

      particleData.push({
        localPos: new THREE.Vector3(x, y, z)
      });
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("customColor", new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

    // === 改进版 Shader ===
    const vertexShader = `
      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;
      varying float vDepth;
      varying vec3 vPos;

      void main() {
        vColor = customColor;
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        vPos = position;
        vDepth = -mvPos.z;
        gl_PointSize = size * (180.0 / vDepth);
        gl_Position = projectionMatrix * mvPos;
      }
    `;

    const fragmentShader = `
      uniform sampler2D pointTexture;
      uniform float time;
      varying vec3 vColor;
      varying float vDepth;
      varying vec3 vPos;

      float rand(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main() {
        vec2 uv = gl_PointCoord - 0.5;
        float dist = length(uv);
        float softness = smoothstep(0.5, 0.0, dist);

        float fresnel = pow(1.0 - abs(dot(normalize(vPos), vec3(0.0, 0.0, 1.0))), 2.5);
        float halo = fresnel * 0.7 + softness * 0.6;

        float flicker = 0.85 + 0.15 * sin(time * 3.0 + rand(uv) * 6.28);

        float attenuation = clamp(1.0 - (vDepth / 300.0), 0.0, 1.0);

        vec3 color = vColor * (halo * flicker * attenuation);
        float alpha = softness * attenuation * 0.9;

        float noise = rand(uv * time * 0.5);
        alpha *= mix(0.85, 1.15, noise);

        gl_FragColor = vec4(color, alpha);
        if (gl_FragColor.a < 0.03) discard;
      }
    `;

    const material = new THREE.ShaderMaterial({
      uniforms: {
        pointTexture: { value: particleSprite },
        time: { value: 0.0 }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // === 动画循环 ===
    function animate() {
      requestAnimationFrame(animate);
      const time = CLOCK.getElapsedTime();
      material.uniforms.time.value = time;

      const dt = 0.015;

      // 漂浮扰动
      for (let i = 0; i < MAIN_PARTICLE_COUNT; i++) {
        const pd = particleData[i];
        const freq = 0.5 + 0.5 * Math.sin(time * 0.3 + pd.localPos.x);
        const amp = 0.02;
        pd.localPos.y += Math.sin(freq + pd.localPos.x * 0.2) * amp * dt;

        positions[i * 3 + 1] = pd.localPos.y;
      }

      geometry.attributes.position.needsUpdate = true;

      particles.rotation.y += 0.001;
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
