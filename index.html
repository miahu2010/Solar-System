<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar Dust X - Native Engine</title>
    <style>
        /* --- 基础样式 --- */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: sans-serif; }
        #canvas-container { position: absolute; inset: 0; z-index: 1; }
        #input-video { display: none; }

        /* --- UI 层 --- */
        .ui { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; color: #aaa; }
        
        /* 侧边栏 */
        #nav { 
            position: absolute; top: 20px; left: 20px; width: 140px; 
            pointer-events: auto; max-height: 80vh; overflow-y: auto;
            background: rgba(20,20,20,0.5); backdrop-filter: blur(10px);
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            padding: 10px;
        }
        .btn {
            display: block; width: 100%; background: none; border: none;
            color: #888; text-align: left; padding: 8px 5px; cursor: pointer;
            font-size: 11px; letter-spacing: 1px; transition: 0.3s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .btn:hover { color: #fff; padding-left: 10px; }
        .btn.active { color: #fff; font-weight: bold; padding-left: 10px; border-left: 2px solid #fff; }

        /* 底部信息 */
        #hud {
            position: absolute; bottom: 30px; left: 30px; right: 30px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        
        #planet-info {
            opacity: 0; transform: translateY(20px); transition: 0.5s;
            text-shadow: 0 0 10px #000;
        }
        #planet-info.show { opacity: 1; transform: translateY(0); }
        
        h1 { margin: 0; font-size: 32px; font-weight: 100; color: #fff; letter-spacing: 4px; }
        .sub { font-size: 10px; text-transform: uppercase; letter-spacing: 2px; color: #666; margin-bottom: 5px; display: block;}
        .details { font-family: monospace; font-size: 10px; color: #888; margin-top: 5px; }

        /* 状态 */
        #status { font-size: 9px; display: flex; align-items: center; gap: 8px; color: #555; }
        .dot { width: 6px; height: 6px; background: #333; border-radius: 50%; }
        .dot.on { background: #fff; box-shadow: 0 0 8px #fff; }

        /* 启动遮罩 */
        #cover {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }
        #btn-start {
            margin-top: 20px; background: transparent; border: 1px solid #444; color: #fff;
            padding: 12px 40px; letter-spacing: 4px; cursor: pointer; font-size: 12px;
            border-radius: 20px; transition: 0.3s;
        }
        #btn-start:hover { border-color: #fff; background: rgba(255,255,255,0.1); }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="cover">
        <div style="font-size: 20px; letter-spacing: 8px; color: #ccc;">SOLAR DUST</div>
        <button id="btn-start">INITIALIZE</button>
    </div>

    <div class="ui">
        <div id="nav"></div>
        
        <div id="hud">
            <div id="status">
                <div class="dot" id="cam-dot"></div>
                <span>OPEN HAND (MIST) / FIST (FORM)</span>
            </div>
            <div id="planet-info">
                <h1 id="p-name">EARTH</h1>
                <span class="sub" id="p-desc">Habitable Zone</span>
                <div class="details" id="p-data">DIA: 12742KM | TMP: 15°C</div>
            </div>
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vShader">
        attribute float size;
        attribute vec3 customPos; // 目标(星球)位置
        attribute float randomScale;

        uniform float uTime;
        uniform float uFist; // 0=Mist, 1=Form
        
        varying float vAlpha;

        void main() {
            vec3 p = position; // 这里的 position 是随机的扩散位置(Mist)
            
            // 1. 动态位置计算
            // 弥散状态: 使用 position (原本是随机的) + 巨大的正弦波浮动
            vec3 mistPos = position;
            mistPos.x += sin(uTime * 0.3 + randomScale * 10.0) * 5.0;
            mistPos.y += cos(uTime * 0.2 + randomScale * 20.0) * 5.0;

            // 实体状态: 使用 customPos (精确的球体表面) + 微小的呼吸
            vec3 formPos = customPos;
            formPos *= 1.0 + sin(uTime * 1.0 + randomScale * 100.0) * 0.01; // 微弱呼吸

            // 混合
            vec3 finalPos = mix(mistPos, formPos, uFist);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            
            // 2. 大小计算 (透视)
            // 实体状态下，粒子稍微变小变密
            float currentSize = size * (2.5 - uFist * 1.5);
            gl_PointSize = currentSize * (200.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;

            // 3. 透明度
            // 实体状态更实(1.0)，弥散状态更虚(0.3)
            vAlpha = 0.3 + uFist * 0.7;
        }
    </script>

    <script type="x-shader/x-fragment" id="fShader">
        uniform sampler2D uTexture;
        uniform vec3 uColor;
        varying float vAlpha;

        void main() {
            // 读取纹理 alpha
            vec4 tex = texture2D(uTexture, gl_PointCoord);
            
            // 颜色叠加：粒子颜色 * 纹理亮度 * 透明度
            gl_FragColor = vec4(uColor, vAlpha * tex.r); 
        }
    </script>

    <script>
        // --- 莫兰迪/低饱和色系 ---
        const DB = [
            { name: "Overview", color: [1,1,1], r: 0, d: 0, s: 0 },
            { name: "Sun", color: [1.0, 0.9, 0.8], r: 10, d: 0, s: 0, desc: "Main Sequence", data: "1.39M km" },
            { name: "Mercury", color: [0.7, 0.7, 0.75], r: 2, d: 20, s: 0.5, desc: "Rocky World", data: "4879 km" },
            { name: "Venus", color: [0.85, 0.8, 0.7], r: 3.5, d: 32, s: 0.4, desc: "Thick Atmosphere", data: "12104 km" },
            { name: "Earth", color: [0.3, 0.5, 0.7], r: 3.8, d: 48, s: 0.3, desc: "Blue Marble", data: "12742 km" },
            { name: "Mars", color: [0.8, 0.45, 0.4], r: 2.5, d: 62, s: 0.25, desc: "Red Planet", data: "6779 km" },
            { name: "Jupiter", color: [0.75, 0.7, 0.6], r: 9, d: 85, s: 0.15, desc: "Gas Giant", data: "139820 km" },
            { name: "Saturn", color: [0.8, 0.75, 0.65], r: 8, d: 110, s: 0.12, ring: true, desc: "Ring System", data: "116460 km" },
            { name: "Uranus", color: [0.65, 0.8, 0.85], r: 6, d: 135, s: 0.1, desc: "Ice Giant", data: "50724 km" },
            { name: "Neptune", color: [0.35, 0.45, 0.8], r: 6, d: 155, s: 0.08, desc: "Windy World", data: "49244 km" }
        ];

        let scene, camera, renderer, controls;
        let uniforms;
        let planets = []; // { mesh, pivot, speed, ... }
        let activeIdx = -1; // -1 Overview
        let state = { fist: 0.0, targetFist: 0.0 };

        // --- 核心：程序化生成光晕纹理 (解决黑屏/方块) ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 黑底
            ctx.fillStyle = '#000000';
            ctx.fillRect(0,0,64,64);
            
            // 白色径向渐变
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, '#ffffff'); // 中心白
            grad.addColorStop(0.3, 'rgba(255,255,255,0.2)'); // 中间淡
            grad.addColorStop(1, '#000000'); // 边缘黑
            
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            document.getElementById('cover').style.opacity = 0;
            setTimeout(() => document.getElementById('cover').style.display = 'none', 800);
            try {
                initVideo();
                init3D();
            } catch(e) {
                console.error(e);
                alert("Initialize failed. Check console.");
            }
        });

        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 100, 180);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000); // 明确设置黑底
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxDistance = 400;

            // 全局变量
            uniforms = {
                uTime: { value: 0 },
                uFist: { value: 0.0 },
                uTexture: { value: createGlowTexture() }
            };

            createStars();
            createSystem();
            createUI();
            
            animate();
            window.addEventListener('resize', onResize);
        }

        function createSystem() {
            DB.forEach((d, i) => {
                if(i === 0) return; // Skip Overview data entry

                const pivot = new THREE.Group();
                scene.add(pivot);

                // 粒子数量：精致感
                const count = d.name === "Sun" ? 5000 : 2000;
                
                const geo = new THREE.BufferGeometry();
                const mistPos = [];   // 属性 position: 随机扩散位置
                const formPos = [];   // 属性 customPos: 球体表面位置
                const scales = [];

                for(let k=0; k<count; k++) {
                    // 1. 计算形态位置 (Form)
                    const r = d.r * Math.cbrt(Math.random()); // 均匀球体
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    
                    const fx = r * Math.sin(phi) * Math.cos(theta);
                    const fy = r * Math.sin(phi) * Math.sin(theta);
                    const fz = r * Math.cos(phi);
                    formPos.push(fx, fy, fz);

                    // 2. 计算弥散位置 (Mist) - 围绕轨道的一团云
                    // 范围比星球大5-8倍
                    const spread = d.r * 6.0;
                    mistPos.push(
                        (Math.random()-0.5) * spread,
                        (Math.random()-0.5) * spread,
                        (Math.random()-0.5) * spread
                    );

                    scales.push(Math.random());
                }

                // 环
                if(d.ring) {
                    for(let k=0; k<1000; k++) {
                        const r = d.r * (1.6 + Math.random() * 1.5);
                        const theta = Math.random() * Math.PI * 2;
                        const x = r * Math.cos(theta);
                        const y = (Math.random()-0.5) * 0.2;
                        const z = r * Math.sin(theta);
                        
                        formPos.push(x, y, z);
                        mistPos.push(x + (Math.random()-0.5)*5, y + (Math.random()-0.5)*5, z + (Math.random()-0.5)*5);
                        scales.push(Math.random());
                    }
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(mistPos, 3));
                geo.setAttribute('customPos', new THREE.Float32BufferAttribute(formPos, 3));
                geo.setAttribute('randomScale', new THREE.Float32BufferAttribute(scales, 1));
                
                // 统一大小属性
                const sizes = new Float32Array(mistPos.length/3).fill(d.name==="Sun"?2.5:1.8);
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        ...uniforms,
                        uColor: { value: new THREE.Color(d.color[0], d.color[1], d.color[2]) }
                    },
                    vertexShader: document.getElementById('vShader').textContent,
                    fragmentShader: document.getElementById('fShader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false, // 必须关闭深度写入，否则会挡住后面的粒子
                    transparent: true
                });

                const mesh = new THREE.Points(geo, mat);
                mesh.position.x = d.d; 
                pivot.add(mesh);

                planets.push({
                    name: d.name,
                    pivot: pivot,
                    mesh: mesh,
                    speed: d.s * 0.002, // 公转速度
                    data: d // 原数据
                });

                // 轨道线 (极细)
                if(d.d > 0) {
                    const orbitGeo = new THREE.RingGeometry(d.d-0.05, d.d+0.05, 128);
                    orbitGeo.rotateX(-Math.PI/2);
                    const orbitMat = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide, transparent:true, opacity:0.15 });
                    scene.add(new THREE.Mesh(orbitGeo, orbitMat));
                }
            });
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<2000; i++) {
                const r = 400 + Math.random()*200;
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(Math.random()*2-1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0x333333, size:2, sizeAttenuation:false});
            scene.add(new THREE.Points(geo, mat));
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            uniforms.uTime.value = time;
            TWEEN.update();

            // 插值手势
            state.fist += (state.targetFist - state.fist) * 0.05;
            uniforms.uFist.value = state.fist;

            // 1. 公转
            planets.forEach(p => {
                p.pivot.rotation.y += p.speed;
            });

            // 2. 镜头死锁 (关键修复)
            if (activeIdx !== -1) {
                // pMeshes 数组顺序: Sun, Mercury... 对应 DB 索引 1...
                // DB[0]是Overview，所以 planets[0] 是 Sun
                const target = planets[activeIdx - 1]; 
                
                if (target && target.mesh) {
                    const worldPos = new THREE.Vector3();
                    target.mesh.getWorldPosition(worldPos);
                    
                    // 强制锁定 OrbitControls 中心
                    controls.target.copy(worldPos);
                    
                    // 注意：不强制设 camera position，只设 target
                    // 这样行星会永远在画面中心，而背景在动
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function focusView(index) {
            activeIdx = index;
            document.querySelectorAll('.btn').forEach((b, i) => b.classList.toggle('active', i===index));
            
            const info = document.getElementById('planet-info');
            
            if (index === 0) { // Overview
                activeIdx = -1; // Reset
                info.classList.remove('show');
                controls.autoRotate = true;
                
                // 飞回全景
                new TWEEN.Tween(camera.position).to({x:0, y:100, z:180}, 1500).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(controls.target).to({x:0, y:0, z:0}, 1500).start();
            } else {
                controls.autoRotate = false;
                const d = DB[index];
                
                document.getElementById('p-name').innerText = d.name.toUpperCase();
                document.getElementById('p-desc').innerText = d.desc;
                document.getElementById('p-data').innerText = `DATA: ${d.data}`;
                info.classList.add('show');
                
                // 调整缩放限制
                controls.minDistance = d.r * 2.0; 
                
                // 飞向大致位置 (后续由 animate 锁定)
                const target = planets[index-1];
                const worldPos = new THREE.Vector3();
                target.mesh.getWorldPosition(worldPos);
                
                // 计算一个偏移位置
                const offset = worldPos.clone().normalize().multiplyScalar(d.r * 5 + 20);
                offset.y += 10;
                
                // 稍微飞近一点，但不完全覆盖位置，保留 Orbit 能力
            }
        }

        function createUI() {
            const nav = document.getElementById('nav');
            DB.forEach((d, i) => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.innerText = d.name;
                if(i===0) btn.classList.add('active');
                btn.onclick = () => focusView(i);
                nav.appendChild(btn);
            });
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Hand Tracking ---
        async function initVideo() {
            const video = document.getElementById('input-video');
            const dot = document.getElementById('cam-dot');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if(res.multiHandLandmarks.length > 0) {
                    dot.classList.add('on');
                    const lm = res.multiHandLandmarks[0];
                    const wrist = lm[0]; const tip = lm[12]; const base = lm[9];
                    if (Math.hypot(tip.x-wrist.x, tip.y-wrist.y) < Math.hypot(base.x-wrist.x, base.y-wrist.y)*1.1)
                        state.targetFist = 1.0;
                    else 
                        state.targetFist = 0.0;
                } else {
                    dot.classList.remove('on');
                }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cam.start();
        }
    </script>
</body>
</html>
