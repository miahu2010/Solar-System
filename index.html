<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar Dust VII - Compatibility Fix</title>
    <style>
        :root {
            --bg: #000000;
            --glass: rgba(255, 255, 255, 0.08);
            --text: #a0a0a0;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
        }

        #canvas-container { position: absolute; inset: 0; z-index: 1; }
        #input-video { display: none; }

        /* UI */
        .ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; }
        .panel {
            pointer-events: auto; background: var(--glass);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;
            padding: 15px; position: absolute; transition: opacity 0.5s;
        }

        /* 导航 */
        #nav { top: 20px; left: 20px; width: 160px; }
        .nav-btn {
            display: block; width: 100%; text-align: left; background: none; border: none;
            color: #666; font-size: 12px; padding: 10px 0; cursor: pointer;
            text-transform: uppercase; letter-spacing: 1px; transition: 0.3s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .nav-btn:hover { color: #fff; padding-left: 5px; }
        .nav-btn.active { color: #fff; font-weight: 600; }

        /* 信息卡片 */
        #info { bottom: 30px; right: 30px; width: 240px; opacity: 0; transform: translateY(20px); }
        #info.show { opacity: 1; transform: translateY(0); }
        h1 { margin: 0; font-size: 28px; color: #fff; font-weight: 200; letter-spacing: 2px; }
        .sub { font-size: 10px; text-transform: uppercase; letter-spacing: 2px; color: #666; margin-bottom: 10px; display: block; }
        .meta { display: flex; justify-content: space-between; margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; font-size: 11px; font-family: monospace; color: #ccc; }

        /* 状态 */
        #status {
            position: absolute; bottom: 30px; left: 30px; font-size: 10px; letter-spacing: 1px;
            display: flex; align-items: center; gap: 8px; opacity: 0.7;
        }
        .dot { width: 6px; height: 6px; background: #444; border-radius: 50%; transition: 0.3s; }
        .dot.on { background: #fff; box-shadow: 0 0 10px #fff; }

        /* 启动层 */
        #overlay {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }
        .btn-start {
            margin-top: 30px; background: transparent; border: 1px solid #333; color: #fff;
            padding: 12px 40px; letter-spacing: 4px; font-size: 12px; cursor: pointer; border-radius: 30px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="overlay">
        <h2 style="font-weight: 100; font-size: 32px; letter-spacing: 8px; color: #fff;">SOLAR MIST</h2>
        <div style="color: #444; font-size: 10px; margin-top: 10px;">HYBRID RENDER ENGINE</div>
        <button class="btn-start" id="start-btn">INITIALIZE SYSTEM</button>
    </div>

    <div class="ui-layer">
        <div class="panel" id="nav">
            <div id="nav-list"></div>
        </div>

        <div class="panel" id="info">
            <h1 id="p-name">EARTH</h1>
            <span class="sub" id="p-type">TERRESTRIAL</span>
            <p style="font-size: 12px; line-height: 1.5; color: #888;" id="p-desc">Our home.</p>
            <div class="meta">
                <span id="p-d">DIA: 12742</span>
                <span id="p-t">TMP: 15°C</span>
            </div>
        </div>

        <div id="status">
            <div class="dot" id="cam-dot"></div>
            <span>GESTURE: OPEN HAND (MIST) / FIST (CORE)</span>
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vertexShader">
        precision highp float;
        
        attribute float size;
        attribute float randomSeed;
        
        uniform float uTime;
        uniform float uFist; // 0=Mist, 1=Solid
        uniform float uScale; // Global scale factor
        
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            vColor = color;
            vec3 p = position;

            // --- 动态逻辑 ---
            // 1. 呼吸浮动 (Mist Floating)
            // 降低频率，增加优雅感
            float floatSpeed = 0.3;
            float floatAmp = 2.0 * (1.0 - uFist); // 握拳时浮动减小
            
            p.x += sin(uTime * floatSpeed + randomSeed * 10.0) * floatAmp;
            p.y += cos(uTime * floatSpeed * 0.8 + randomSeed * 20.0) * floatAmp;
            p.z += sin(uTime * floatSpeed * 0.5 + randomSeed * 30.0) * floatAmp;

            // 2. 爆炸/聚合 (Explosion/Implosion)
            // 当 uFist=0 (Open Hand)，粒子向外炸开成云雾
            // 使用 normalize(p) 沿着半径方向推
            vec3 mistOffset = normalize(p) * (length(p) * 2.5 * randomSeed);
            
            // 混合位置：在 雾(Mist) 和 实体(Solid) 之间过渡
            vec3 finalPos = mix(p + mistOffset, p, uFist);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            
            // 3. 大小衰减
            // 握拳时粒子小而密，张开时大而虚
            float targetSize = size * (3.0 - uFist * 1.5); 
            gl_PointSize = targetSize * (200.0 / -mvPosition.z); // 增加透视感
            gl_Position = projectionMatrix * mvPosition;

            // 4. 透明度逻辑
            // 雾化状态更透明
            vAlpha = 0.2 + uFist * 0.6;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        
        uniform sampler2D uTexture; // 使用贴图！
        varying vec3 vColor;
        varying float vAlpha;
        
        void main() {
            // 从生成的圆形贴图中读取透明度
            vec4 texColor = texture2D(uTexture, gl_PointCoord);
            
            // 如果贴图透明度太低，丢弃 (优化性能)
            if (texColor.a < 0.05) discard;

            // 颜色混合： 粒子颜色 * 贴图alpha * 全局alpha
            gl_FragColor = vec4(vColor, vAlpha * texColor.a);
        }
    </script>

    <script>
        // --- 配置: 莫兰迪/深空色系 ---
        const DB = [
            { name: "System", type: "Overview", color: [1,1,1], r: 0, d: 0, s: 0 },
            { name: "Sun", type: "Star", color: [1.0, 0.9, 0.8], r: 12, d: 0, s: 0, desc: "Silent Light.", data: ["1.39M", "5500°C"] },
            { name: "Mercury", type: "Planet", color: [0.7, 0.7, 0.75], r: 2, d: 30, s: 0.6, desc: "Grey Dust.", data: ["4879", "167°C"] },
            { name: "Venus", type: "Planet", color: [0.85, 0.8, 0.7], r: 3.5, d: 45, s: 0.5, desc: "Pale Clouds.", data: ["12104", "464°C"] },
            { name: "Earth", type: "Home", color: [0.3, 0.5, 0.75], r: 3.8, d: 65, s: 0.4, desc: "Blue Mist.", data: ["12742", "15°C"] },
            { name: "Mars", type: "Planet", color: [0.8, 0.45, 0.4], r: 2.5, d: 85, s: 0.35, desc: "Red Sand.", data: ["6779", "-65°C"] },
            { name: "Jupiter", type: "Gas Giant", color: [0.75, 0.7, 0.6], r: 10, d: 120, s: 0.2, desc: "The Giant.", data: ["139820", "-110°C"] },
            { name: "Saturn", type: "Gas Giant", color: [0.8, 0.75, 0.6], r: 9, d: 160, s: 0.15, ring: true, desc: "Ringed One.", data: ["116460", "-140°C"] },
            { name: "Uranus", type: "Ice Giant", color: [0.6, 0.75, 0.8], r: 6, d: 200, s: 0.1, desc: "Cyan Ice.", data: ["50724", "-195°C"] },
            { name: "Neptune", type: "Ice Giant", color: [0.3, 0.4, 0.8], r: 6, d: 240, s: 0.08, desc: "Deep Void.", data: ["49244", "-200°C"] }
        ];

        let scene, camera, renderer, controls;
        let uniforms;
        let pGroups = [];
        let pMeshes = [];
        let activeIdx = 0;
        let state = { fist: 0.0, targetFist: 0.0 }; // 默认0 (张开/雾化)

        // --- 核心修复：生成完美的圆形贴图 ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 画一个柔和的径向渐变圆
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); // 中心亮
            grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)'); // 过渡柔和
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)'); // 边缘完全透明
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 800);
            initCam();
            init3D();
        });

        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0015); // 黑雾

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.set(0, 120, 240); // 默认总览位置

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxDistance = 600;

            // 全局 Uniforms
            uniforms = {
                uTime: { value: 0 },
                uFist: { value: 0.0 },
                uTexture: { value: createParticleTexture() } // 注入贴图
            };

            // 创建星空 (背景层)
            createStars();
            
            // 创建行星
            DB.forEach((d, i) => {
                if(i > 0) createPlanet(d, i);
            });

            createUI();
            animate();
            window.addEventListener('resize', onResize);
        }

        function createPlanet(data, index) {
            const pivot = new THREE.Group();
            scene.add(pivot);

            // 粒子数量：保证性能，不要太多，追求精致
            const count = data.name === "Sun" ? 3000 : 1200;
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const seeds = [];

            const colorBase = new THREE.Color(data.color[0], data.color[1], data.color[2]);
            const hsl = {}; colorBase.getHSL(hsl);

            for(let i=0; i<count; i++) {
                // 球体分布
                const r = data.r * Math.pow(Math.random(), 0.5); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );

                // 颜色微调 (更淡雅)
                const c = new THREE.Color().setHSL(hsl.h, hsl.s * 0.6, hsl.l + (Math.random()-0.5)*0.15);
                colors.push(c.r, c.g, c.b);

                // 随机大小和种子
                sizes.push(Math.random() * 1.5 + 0.5);
                seeds.push(Math.random());
            }

            // 环
            if(data.ring) {
                for(let i=0; i<800; i++) {
                    const r = data.r * (1.6 + Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    positions.push(r*Math.cos(theta), (Math.random()-0.5)*0.2, r*Math.sin(theta));
                    colors.push(0.6, 0.6, 0.55);
                    sizes.push(0.8);
                    seeds.push(Math.random());
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('randomSeed', new THREE.Float32BufferAttribute(seeds, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending, // 加法混合 (关键)
                depthWrite: false, // 关键：关闭深度写入，防止方块遮挡透明度
                transparent: true
            });

            const mesh = new THREE.Points(geometry, material);
            mesh.position.x = data.d; // 初始距离
            pivot.add(mesh);

            pGroups.push({ pivot, speed: data.s });
            pMeshes.push(mesh);

            // 极细轨道线
            if(data.d > 0) {
                const geo = new THREE.RingGeometry(data.d-0.05, data.d+0.05, 128);
                geo.rotateX(-Math.PI/2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.05, side:THREE.DoubleSide });
                scene.add(new THREE.Mesh(geo, mat));
            }
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1500; i++) {
                const r = 500 + Math.random()*300;
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(Math.random()*2-1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            // 背景星星使用简单的 PointsMaterial 即可，性能最好
            const mat = new THREE.PointsMaterial({color:0x555555, size:1.5, sizeAttenuation:false, transparent:true, opacity:0.4});
            scene.add(new THREE.Points(geo, mat));
        }

        // --- 逻辑循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            uniforms.uTime.value = time;
            TWEEN.update();

            // 手势平滑过渡
            state.fist += (state.targetFist - state.fist) * 0.05;
            uniforms.uFist.value = state.fist;

            // 公转
            pGroups.forEach(g => {
                g.pivot.rotation.y += g.speed * 0.001;
            });

            // 镜头锁定逻辑
            if(activeIdx > 0) {
                const mesh = pMeshes[activeIdx - 1]; // -1 因为DB[0]是system
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                controls.target.lerp(worldPos, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function switchView(idx) {
            activeIdx = idx;
            document.querySelectorAll('.nav-btn').forEach((b, i) => b.classList.toggle('active', i===idx));
            
            const info = document.getElementById('info');
            
            if(idx === 0) { // Overview
                info.classList.remove('show');
                controls.autoRotate = true;
                // 拉远
                new TWEEN.Tween(camera.position).to({x:0, y:120, z:240}, 1500).easing(TWEEN.Easing.Quadratic.Out).start();
                new TWEEN.Tween(controls.target).to({x:0, y:0, z:0}, 1500).start();
            } else { // Focus Planet
                controls.autoRotate = false;
                const d = DB[idx];
                document.getElementById('p-name').innerText = d.name.toUpperCase();
                document.getElementById('p-type').innerText = d.desc; // Using desc as type for visual layout
                document.getElementById('p-desc').innerText = `Distance: ${d.d} AU`;
                document.getElementById('p-d').innerText = `DIA: ${d.data[0]}`;
                document.getElementById('p-t').innerText = `TMP: ${d.data[1]}`;
                info.classList.add('show');
                
                // 调整 Zoom 限制，允许看清行星
                controls.minDistance = d.r * 2.0; 
            }
        }

        // --- UI ---
        function createUI() {
            const list = document.getElementById('nav-list');
            DB.forEach((d, i) => {
                const btn = document.createElement('button');
                btn.className = 'nav-btn';
                btn.innerText = d.name;
                if(i===0) btn.classList.add('active');
                btn.onclick = () => switchView(i);
                list.appendChild(btn);
            });
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 手势识别 ---
        async function initCam() {
            const video = document.getElementById('input-video');
            const dot = document.getElementById('cam-dot');
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5});
            
            hands.onResults(res => {
                if(res.multiHandLandmarks.length > 0) {
                    dot.classList.add('on');
                    const lm = res.multiHandLandmarks[0];
                    // 简单握拳判定
                    const wrist = lm[0];
                    const tip = lm[12]; 
                    const base = lm[9];
                    
                    const dTip = Math.hypot(tip.x-wrist.x, tip.y-wrist.y);
                    const dBase = Math.hypot(base.x-wrist.x, base.y-wrist.y);
                    
                    // 指尖距离手腕 比 指根距离手腕更近 = 握拳
                    if(dTip < dBase * 1.1) state.targetFist = 1.0; 
                    else state.targetFist = 0.0;
                } else {
                    dot.classList.remove('on');
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240
            });
            cam.start();
        }
    </script>
</body>
</html>
